{
  "releases": ["2025-02-19"],
  "tags": [
    "api",
    "ci/cd",
    "cli",
    "code formatting",
    "data i/o",
    "data wrangling",
    "database",
    "dbms",
    "deployment",
    "general",
    "logging",
    "machine learning",
    "performance",
    "queue",
    "rest",
    "task scheduling",
    "typing",
    "validation and testing",
    "virtualization",
    "visualization"
  ],
  "items": [
    {
      "id": "airflow",
      "release": "2025-02-19",
      "title": "Airflow",
      "ring": "trial",
      "quadrant": "infra",
      "body": "<p>Apache Airflow is a workflow orchestration tool designed for managing complex data pipelines. It powers the MIMIR data platform, and is being used in its own in UrbSim (authored by Robin Houdmeyers. While powerful, it has a steep learning curve and can be overkill for simple scheduling needs. For lightweight task scheduling, APScheduler is a simpler alternative.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["task scheduling"],
      "position": [278, 613]
    },
    {
      "id": "alembic",
      "release": "2025-02-19",
      "title": "alembic",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Alembic is a database migration tool for SQLAlchemy, providing a structured way to manage and version database schema changes. It supports autogeneration of migrations, making it easier to track and apply schema updates consistently. Alembic is essential for projects using SQLAlchemy, ensuring that database schemas remain in sync across development, testing, and production environments.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [245, 355]
    },
    {
      "id": "amqp",
      "release": "2025-02-19",
      "title": "AMQP",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>Advanced Message Queuing Protocol. A robust, feature-rich messaging protocol. It supports message delivery guarantees, routing, and advanced messaging patterns. Use RabbitMQ as your broker, with pika for low-level control or Celery for task-based asynchronous processing.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["queue"],
      "position": [329, 438]
    },
    {
      "id": "aniso8601",
      "release": "2025-02-19",
      "title": "aniso8601",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>aniso8601 is a Python library for parsing and formatting ISO 8601 date and time strings, which the standard datatime library is not capable of. It supports a wide range of ISO 8601 formats, including durations, intervals, and repeating intervals, making it useful for working with standardized date-time data. In research and data processing pipelines, it ensures consistent handling of temporal data across various systems.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [467, 359]
    },
    {
      "id": "apptainer",
      "release": "2025-02-19",
      "title": "Apptainer",
      "ring": "trial",
      "quadrant": "infra",
      "body": "<p>Apptainer (formerly Singularity) is a containerization tool often used in high-performance computing (HPC) environments. While it shares similarities with Docker, Apptainer is designed for secure, portable containers. It’s worth assessing for HPC-specific use cases, but for general containerization, Docker remains the preferred option.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["virtualization"],
      "position": [181, 439]
    },
    {
      "id": "apscheduler",
      "release": "2025-02-19",
      "title": "apscheduler",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>APScheduler is a flexible Python library for scheduling jobs. It supports cron-like scheduling, fixed intervals, and date-based execution. With its straightforward API, persistence options, and integration capabilities, APScheduler is a reliable choice for managing scheduled tasks in Python applications.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["task scheduling"],
      "position": [368, 548]
    },
    {
      "id": "argparse",
      "release": "2025-02-19",
      "title": "argparse",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>argparse is the standard library for command-line argument parsing in Python. While it is reliable and widely used, its syntax can be verbose and less intuitive for complex CLIs. We recommend using Typer for new projects due to its cleaner API, type hints support, and better developer experience. Existing scripts using argparse can remain, but new command-line tools should use Typer.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["cli"],
      "position": [86, 197]
    },
    {
      "id": "boto3",
      "release": "2025-02-19",
      "title": "boto3",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>boto3 is the official Python SDK for AWS, providing a comprehensive interface to interact with AWS services like S3, EC2, DynamoDB, and more. It supports both high-level resource abstractions and low-level API calls, making it suitable for various tasks ranging from simple operations to complex cloud automation. Given its reliability, active maintenance, and official status, boto3 is the default choice for interacting with AWS in Python projects.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [523, 335]
    },
    {
      "id": "cachetools",
      "release": "2025-02-19",
      "title": "cachetools",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>cachetools is a Python library that provides in-memory caching with multiple eviction policies, such as Least Recently Used (LRU) and Time-To-Live (TTL). It’s useful for optimizing performance in scenarios where expensive function calls or frequent data retrievals can be cached. cachetools integrates easily with Python’s functools.lru_cache and offers more control over cache behavior, making it ideal for custom caching solutions.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["performance"],
      "position": [342, 258]
    },
    {
      "id": "celery",
      "release": "2025-02-19",
      "title": "Celery",
      "ring": "assess",
      "quadrant": "infra",
      "body": "<p>Celery is a distributed task queue for handling asynchronous jobs and scheduling tasks in Python. It’s widely used for background task processing, such as sending emails, processing data, or integrating external services. Celery supports multiple message brokers (e.g., RabbitMQ, Redis). Compared to lower-level solutions like pika, Celery simplifies task management with built-in retries, scheduling, and monitoring capabilities.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["queue"],
      "position": [161, 612]
    },
    {
      "id": "conda-mamba",
      "release": "2025-02-19",
      "title": "conda/mamba",
      "ring": "adopt",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>Conda is the most widely used environment and package manager in the team, with varying levels of strictness in how it’s applied—ranging from simple environment.yml files for Jenkins builds to meticulous dependency management. The RDM team explicitly requested a shared Conda environment for consistent use across projects. However, with the rise of Pixi, Conda’s position might shift. If Pixi proves reliable and gains broader adoption, Conda could move to Hold.</p>\n",
      "featured": true,
      "flag": "default",
      "position": [484, 518]
    },
    {
      "id": "cx_freeze",
      "release": "2025-02-19",
      "title": "cx_freeze",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>cx_Freeze is a tool for converting Python scripts into standalone executables for Windows, macOS, and Linux. While it remains functional, modern alternatives like Docker offer more flexible and reproducible ways to distribute applications, especially in containerized environments. Additionally, cx_Freeze does not play well with certain packages like GDAL, making it less suitable for geospatial projects. For most use cases, we recommend using Docker or other packaging solutions. Existing use cases can remain, but it should not be used for new projects.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["general"],
      "position": [207, 75]
    },
    {
      "id": "cyclopts",
      "release": "2025-02-19",
      "title": "cyclopts",
      "ring": "assess",
      "quadrant": "app-dev",
      "body": "<p>Cyclopts is a CLI-building library that addresses some limitations of Typer, particularly with custom types as arguments. It competes with argparse and offers excellent validation along with automatic help generation. While it shows potential, it is still relatively new and not widely adopted as of February 2025. Further evaluation is needed before broader use.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["cli"],
      "position": [327, 91]
    },
    {
      "id": "dask",
      "release": "2025-02-19",
      "title": "dask",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Dask scales Python workflows for large datasets and parallel computing. It extends pandas, NumPy, and scikit-learn for out-of-core and distributed computations. Ideal for handling data that doesn’t fit in memory or for scaling across multiple cores or clusters. Stick with pandas for smaller datasets to keep things simpler.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["performance"],
      "position": [279, 278]
    },
    {
      "id": "django",
      "release": "2025-02-19",
      "title": "Django",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>Django is a comprehensive web framework with built-in features like an ORM, authentication, and an admin interface. While powerful, it’s often more than what’s needed for our use cases. FastAPI offers a lighter, more modern alternative for building APIs with better performance and flexibility. Existing Django projects can remain, but for new projects, we recommend using FastAPI.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["api"],
      "position": [144, 145]
    },
    {
      "id": "docker",
      "release": "2025-02-19",
      "title": "Docker",
      "ring": "adopt",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>Docker is a general-purpose containerization tool that provides a reproducible, isolated environment for managing dependencies. Its learning curve is steep, but we encourage the use of Docker. It should, however, be combined with a dedicated dependency manager (e.g., Conda, Pixi, or uv) inside the container for better package management.</p>\n",
      "featured": true,
      "flag": "default",
      "position": [529, 516]
    },
    {
      "id": "docker_swarm",
      "release": "2025-02-19",
      "title": "Docker Swarm",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>Docker Swarm is a lightweight container orchestration tool built into Docker. It is easy to set up and remains the preferred choice for the foreseeable future while our Kubernetes migration is ongoing. Though it may become outdated, migration from Swarm to Kubernetes should be straightforward when the time comes.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["deployment"],
      "position": [295, 481]
    },
    {
      "id": "duckdb",
      "release": "2025-02-19",
      "title": "DuckDB",
      "ring": "assess",
      "quadrant": "infra",
      "body": "<p>DuckDB is an in-process SQL database designed for fast analytical queries on large datasets. Often described as the &quot;SQLite for analytics,&quot; it supports columnar storage and works seamlessly with data in Parquet and Arrow formats. While still evolving, DuckDB shows promise for specific tasks like data exploration, lightweight analytics, and working with large tabular datasets in memory. It’s worth testing in isolated workloads.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["database", "dbms"],
      "position": [94, 506]
    },
    {
      "id": "dynaconf",
      "release": "2025-02-19",
      "title": "dynaconf",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>Dynaconf is a flexible configuration management library for Python. It supports multiple configuration sources, such as environment variables, .toml, .yaml, .json files, and even external services like Redis or Vault. It offers layered configurations, type casting, and seamless environment switching (e.g., development, staging, production). Currently trialing this alongside pydantic-settings.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [250, 192]
    },
    {
      "id": "fastai",
      "release": "2025-02-19",
      "title": "fastai",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>fastai is a high-level library built on top of PyTorch, designed to simplify deep learning model training. It provides pre-built workflows for tasks like image classification and natural language processing, achieving state-of-the-art results with minimal effort. However, it abstracts away much of the underlying framework, making it less suitable for custom projects or large-scale production.\nfastai is primarily recommended for educational purposes or rapid prototyping. For serious research or production work, choose Tensorflow or PyTorch.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [624, 102]
    },
    {
      "id": "fastapi",
      "release": "2025-02-19",
      "title": "fastapi",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>FastAPI is a modern web framework for building APIs in Python. It is fast, easy to use, and built with type hints for better validation and developer experience. It has strong documentation, automatic OpenAPI generation, and async support, making it well-suited for high-performance applications. With growing adoption and a strong ecosystem, it is the preferred choice for building APIs in Python (over Flask and Django).</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["api"],
      "position": [313, 300]
    },
    {
      "id": "fiona",
      "release": "2025-02-19",
      "title": "fiona",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Fiona is a library for reading and writing vector data, built on top of GDAL. While typically more low-level, it forms the backbone for higher-level libraries like GeoPandas. For most common geospatial tasks, GeoPandas is sufficient, but Fiona can be useful when more control over file formats and advanced I/O operations is required. It remains an essential part of the Python geospatial ecosystem.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [424, 266]
    },
    {
      "id": "flake8",
      "release": "2025-02-19",
      "title": "Flake8",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>flake8 is a linting tool that combines Pyflakes, pycodestyle, and McCabe for checking code style and complexity. While it has been a popular choice, it lacks the speed and broader functionality of newer tools like Ruff, which now covers most of flake8’s features with much better performance. For new projects, we recommend using Ruff instead. Even for existing projects, switching to Ruff is advised.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["code formatting"],
      "position": [668, 124]
    },
    {
      "id": "flask",
      "release": "2025-02-19",
      "title": "flask",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>Flask is a lightweight web framework for building web applications in Python. While it has been widely used and remains suitable for existing projects, we no longer recommend it for new development. FastAPI offers significant advantages, such as built-in type validation, asynchronous support, and automatic OpenAPI generation. Legacy Flask projects will not be converted to FastAPI, but for new projects, FastAPI is the preferred framework.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["api"],
      "position": [103, 159]
    },
    {
      "id": "folium",
      "release": "2025-02-19",
      "title": "folium",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Folium is a Python library for creating interactive maps using Leaflet.js. It makes it easy to visualize geospatial data directly in Python notebooks by rendering interactive web-based maps. This is especially useful in a research context for quick exploration and presentation of spatial data. Folium integrates well with pandas and GeoPandas, allowing for simple mapping of dataframes containing geographic information.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["visualization"],
      "position": [433, 373]
    },
    {
      "id": "gdal",
      "release": "2025-02-19",
      "title": "gdal",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>GDAL is a powerful library for working with raster and vector geospatial data. However, we recommend avoiding its direct use in Python. Instead, prefer higher-level libraries like geopandas, rasterio for raster data and fiona for vector data. These libraries provide a more Pythonic and readable interface while still leveraging GDAL under the hood. Shapely and GeoPandas can handle most geometry-related tasks, further reducing the need for direct GDAL usage.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [473, 32]
    },
    {
      "id": "geoalchemy2",
      "release": "2025-02-19",
      "title": "geoalchemy2",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>GeoAlchemy2 extends SQLAlchemy to support spatial databases, specifically PostGIS. It provides tools for working with geospatial data in relational databases, allowing spatial queries and operations within SQLAlchemy models. As the standard interface for PostGIS in Python, it is essential for geospatial database applications.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [444, 353]
    },
    {
      "id": "geopandas",
      "release": "2025-02-19",
      "title": "geopandas",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>GeoPandas extends pandas to handle geospatial data, providing support for spatial operations and file formats. There is no real alternative for spatial data manipulation in Python at this level of abstraction. It is essential for working with geospatial data and widely used in GIS applications.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [489, 243]
    },
    {
      "id": "geopolars",
      "release": "2025-02-19",
      "title": "geopolars",
      "ring": "assess",
      "quadrant": "research-dev",
      "body": "<p>GeoPolars is an emerging library for geospatial data processing built on top of Polars. It aims to offer performance improvements over GeoPandas but is still under active development. While promising, it currently lacks key features, and GeoPandas remains the more mature and reliable choice. Development is being monitored internally by Lorenz Hambsch.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [501, 110]
    },
    {
      "id": "h5py",
      "release": "2025-02-19",
      "title": "h5py",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>h5py is a Python interface for the HDF5 file format, which is commonly used for storing and managing large numerical datasets. It allows for efficient reading and writing of hierarchical data structures and integrates well with NumPy for seamless array manipulation. h5py is widely used in scientific computing, especially in fields like machine learning, bioinformatics, and geospatial analysis, making it a key tool for handling large-scale data.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [436, 301]
    },
    {
      "id": "httpx",
      "release": "2025-02-19",
      "title": "httpx",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>httpx is a modern HTTP client for Python that provides async support and a more flexible API than requests. It is useful for applications requiring high-performance network requests, but adoption is still limited compared to requests. While promising, httpx is being evaluated for broader production use.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [197, 281]
    },
    {
      "id": "jenkins",
      "release": "2025-02-19",
      "title": "Jenkins",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>Jenkins is a widely adopted automation server for continuous integration and delivery (CI/CD). Compared to cloud-based solutions like GitHub Actions or CircleCI, Jenkins offers full control over infrastructure, making it ideal for self-hosted environments. Its extensive plugin ecosystem and active community support a broad range of use cases, from simple pipelines to complex CI/CD workflows.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["ci/cd"],
      "position": [341, 549]
    },
    {
      "id": "jinja2",
      "release": "2025-02-19",
      "title": "jinja2",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Jinja2 is a powerful templating engine for Python, commonly used for generating HTML, configuration files, or other text-based formats. In a research context, it is particularly useful for automating the generation of large sets of structured files, such as experiment configurations or reports</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["general"],
      "position": [365, 390]
    },
    {
      "id": "joblib",
      "release": "2025-02-19",
      "title": "joblib",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>joblib is a lightweight library for parallel processing and caching in Python. It simplifies parallelizing tasks with a readable and intuitive API, making it a preferred choice for tasks like data processing, model training, and scientific computations. joblib integrates well with scikit-learn and supports efficient file-based caching for large data objects, reducing recomputation time.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["performance"],
      "position": [377, 321]
    },
    {
      "id": "kubernetes",
      "release": "2025-02-19",
      "title": "Kubernetes",
      "ring": "trial",
      "quadrant": "infra",
      "body": "<p>Kubernetes is a powerful container orchestration platform with strong community support and a broad ecosystem. While simple workloads, such as frontends, can already run on our cluster, Kubernetes is not yet production-ready for more complex deployments, especially those involving databases. The platform is still under development. Reach out to Guy Driesen, Koen Dierckx or Augusto Leite Pinto De Carvalho for more context.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["deployment"],
      "position": [182, 522]
    },
    {
      "id": "loguru",
      "release": "2025-02-19",
      "title": "loguru",
      "ring": "trial",
      "quadrant": "research-dev",
      "body": "<p>loguru offers a more user-friendly alternative to Python’s built-in logging module, with sane defaults and an intuitive API. It simplifies logging setup, provides easy filtering by log level, and supports advanced features like sinks for handling logs from different packages. While we are still trialing this internally, it shows promise as a more manageable logging solution compared to the built-in logging module.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["logging"],
      "position": [501, 177]
    },
    {
      "id": "matplotlib",
      "release": "2025-02-19",
      "title": "matplotlib",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>Matplotlib is a comprehensive library for static plotting in Python, widely used for generating simple plots. However, its API can be verbose, and the default visual style feels outdated. For production settings or more polished visuals, we recommend Plotly. Matplotlib still has its merits for quick, exploratory visualizations during debugging.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["visualization"],
      "position": [734, 217]
    },
    {
      "id": "mqtt",
      "release": "2025-02-19",
      "title": "MQTT",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>Message Queuing Telemetry Transport. A lightweight, publish-subscribe protocol designed for low-bandwidth, low-latency messaging (commonly used in IoT). Use Mosquitto as your broker, with paho-mqtt as the client. This provides full MQTT compliance and is perfectly suitable for IoT use cases. Avoid using RabbitMQ with the MQTT plugin, as it doesn&#39;t fully implement all MQTT features.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["queue"],
      "position": [346, 450]
    },
    {
      "id": "mypy",
      "release": "2025-02-19",
      "title": "mypy",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>mypy is a static type checker for Python that enforces type annotations, helping to catch potential bugs early and improve code maintainability. It is widely used in larger codebases and integrates well with CI/CD pipelines. However, with ruff&#39;s type-checking features on the horizon, we are monitoring its development closely. If ruff proves to be a reliable alternative, mypy may eventually become unnecessary for new projects.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [312, 260]
    },
    {
      "id": "narwhals",
      "release": "2025-02-19",
      "title": "narwhals",
      "ring": "assess",
      "quadrant": "app-dev",
      "body": "<p>narwhals is a library that provides a unified API for working with both pandas and Polars data frames, offering an abstraction layer to switch between them seamlessly. While promising, it is still under development, and its long-term stability and adoption remain uncertain. Suitable for exploration but not yet recommended for widespread use.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [154, 212]
    },
    {
      "id": "netcdf4",
      "release": "2025-02-19",
      "title": "netcdf4",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>netCDF4 is a Python library for working with netCDF files, a standard format for storing multi-dimensional scientific data such as climate models, satellite observations, and oceanographic data. It provides efficient reading, writing, and manipulation of netCDF datasets. Widely used in research, it integrates well with NumPy and xarray, making it essential for handling large-scale structured data in scientific applications.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [415, 360]
    },
    {
      "id": "numba",
      "release": "2025-02-19",
      "title": "numba",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Numba is a just-in-time (JIT) compiler for Python that can significantly speed up numerical computations by converting Python functions into optimized machine code. It works particularly well with NumPy arrays and loops, offering performance comparable to compiled languages like C. However, its effectiveness can vary depending on the use case—when it works, it’s great, but not all Python code can be easily optimized with Numba. It&#39;s worth experimenting with for performance-critical tasks.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["performance"],
      "position": [457, 378]
    },
    {
      "id": "numexpr",
      "release": "2025-02-19",
      "title": "numexpr",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>numexpr is a fast numerical expression evaluator for NumPy arrays. It optimizes performance by leveraging multi-threading and efficient memory usage, making it significantly faster than plain NumPy for large array computations. It is particularly useful for accelerating element-wise operations and complex expressions without changing much code. Ideal for data-intensive tasks where performance matters.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["performance"],
      "position": [456, 299]
    },
    {
      "id": "numpy",
      "release": "2025-02-19",
      "title": "numpy",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>NumPy is a fundamental package for numerical computing in Python. It provides efficient array operations, mathematical functions, and linear algebra utilities. Many libraries, including pandas, SciPy, and scikit-learn, depend on it. Given its performance, stability, and widespread adoption, NumPy is the default choice for numerical data handling in Python.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [530, 288]
    },
    {
      "id": "openpyxl",
      "release": "2025-02-19",
      "title": "openpyxl",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>openpyxl is the preferred library for reading and writing Excel files in Python, supporting .xlsx and .xlsm formats. It provides a robust feature set for manipulating cell data, styles, formulas, and more. Compared to alternatives like xlrd (deprecated for .xlsx) and xlwt (limited to .xls format), openpyxl is the most reliable and actively maintained choice for working with modern Excel files. Avoid using older libraries like xlrd, xlwt, and pyExcelerator.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [553, 338]
    },
    {
      "id": "overrides",
      "release": "2025-02-19",
      "title": "overrides",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>overrides is a Python decorator that ensures methods in subclasses correctly override methods in parent classes. It helps catch errors like signature mismatches or accidental method duplication at development time, improving code clarity and maintainability. This is particularly useful in object-oriented codebases where explicit overrides help maintain consistency and prevent bugs. While familiar to those with a Java background, it may be less intuitive for developers new to object-oriented programming.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["general"],
      "position": [241, 225]
    },
    {
      "id": "pandas",
      "release": "2025-02-19",
      "title": "pandas",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>pandas is the standard library for data manipulation in Python. While its syntax can be inconsistent, it has extensive documentation, many online examples, and strong AI tool support. It integrates well with libraries like NumPy, Matplotlib, and GeoPandas, making it a key part of the Python data ecosystem. Its broad adoption and rich feature set make it the default choice for working with structured data.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [499, 317]
    },
    {
      "id": "pandera",
      "release": "2025-02-19",
      "title": "pandera",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>pandera is a data validation library for pandas and other dataframe libraries, enabling schema enforcement and type checking. It looks promising and is encouraged for use in projects, but it has yet to gain widespread adoption. Given its potential, it is likely to move to Adopt as exposure increases.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [331, 183]
    },
    {
      "id": "parse",
      "release": "2025-02-19",
      "title": "parse",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>parse is a Python library for parsing and extracting data from strings based on predefined patterns. In other words, it&#39;s a complement of str.format(). It offers a more readable and Pythonic alternative to regular expressions for simple string matching and extraction tasks. With its clean syntax and intuitive API, it’s a useful tool for tasks like log parsing, configuration reading, and structured data extraction from text.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [431, 235]
    },
    {
      "id": "pip",
      "release": "2025-02-19",
      "title": "pip",
      "ring": "hold",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>pip is fine for installing individual packages but not for managing environments. It lacks isolation, does not handle non-Python dependencies, and does not track project requirements. Use virtualenv for basic isolation or tools like Conda and Pixi for full environment management. These tools may still use pip but you should not use pip on its own</p>\n",
      "featured": true,
      "flag": "default",
      "position": [729, 577]
    },
    {
      "id": "pixi",
      "release": "2025-02-19",
      "title": "pixi",
      "ring": "trial",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>Pixi is a promising new tool that works with both Conda and PyPI registries, ensuring reproducibility with a combination of pyproject.toml and pixi.lock. Dependencies stay up-to-date with pixi add, and its use is spreading organically across the team. However, it cannot build packages yet. There are also concerns about whether it encourages researchers to upgrade dependencies regularly—something enforced naturally with Conda environments.</p>\n",
      "featured": true,
      "flag": "default",
      "position": [478, 641]
    },
    {
      "id": "plotly",
      "release": "2025-02-19",
      "title": "plotly",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Plotly is a visualization library for creating interactive charts. It supports exporting charts as JSON, which can be rendered in the frontend using JavaScript. It is easy to use and supports a wide range of chart types, including geo data visualizations. While frontend teams primarily use Recharts, Plotly remains a good choice for Python-based applications requiring interactive visualizations.</p>\n<p>We suggest to use plotly over matplotlib, seaborn and bokeh</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["visualization"],
      "position": [506, 365]
    },
    {
      "id": "poetry",
      "release": "2025-02-19",
      "title": "poetry",
      "ring": "hold",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>Poetry was previously used for dependency and package management, but with the adoption of uv, it is no longer useful. uv is better across the board and faster. We suggest you switch over existing projects that use poetry to use uv instead.</p>\n",
      "featured": true,
      "flag": "default",
      "position": [532, 754]
    },
    {
      "id": "polars",
      "release": "2025-02-19",
      "title": "polars",
      "ring": "assess",
      "quadrant": "research-dev",
      "body": "<p>Polars is a high-performance DataFrame library designed for large-scale data processing. It’s significantly faster than pandas for operations on very large datasets (millions of rows), thanks to its columnar memory layout and Rust-based engine. While promising, it’s currently less mature than pandas, with limited ecosystem integration.\nGeopolars, its geospatial counterpart, is still in a pre-alpha stage, making it unsuitable for geospatial tasks at this time. For geospatial data, GeoPandas—which now supports Apache Arrow—remains the more reliable choice. Polars is definitely one to watch as it continues to evolve.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [677, 246]
    },
    {
      "id": "postgis",
      "release": "2025-02-19",
      "title": "PostGIS",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>PostGIS is a spatial database extension for PostgreSQL, adding support for geographic objects and geospatial queries. It enables advanced spatial operations like intersections, and distance calculations directly within SQL. Integrating nicely with GeoPandas and QGIS, PostGIS is essential for projects involving spatial data.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["database"],
      "position": [322, 485]
    },
    {
      "id": "postgresql",
      "release": "2025-02-19",
      "title": "PostgreSQL",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>PostgreSQL is a powerful, open-source relational database known for its reliability, scalability, and extensive feature set. It supports advanced features like full-text search, JSONB storage, and geospatial queries through PostGIS, making it versatile for a wide range of applications. PostgreSQL is preferred over MySQL for its stricter compliance with SQL standards, better concurrency handling, and advanced extensibility.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["database"],
      "position": [315, 531]
    },
    {
      "id": "postgrest",
      "release": "2025-02-19",
      "title": "PostgREST",
      "ring": "hold",
      "quadrant": "infra",
      "body": "<p>PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations. Although it allow a quick spinup of a RESTfull API based on the database model, it also limits features outside PostgRESTs capabilities. We advise not to use this because of poor ways to extend beyond it.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["database", "rest"],
      "position": [194, 704]
    },
    {
      "id": "prefect",
      "release": "2025-02-19",
      "title": "Prefect",
      "ring": "assess",
      "quadrant": "infra",
      "body": "<p>Prefect is an alternative to Airflow that simplifies workflow orchestration and makes it easy to turn Python code into a managed workflow. It offers a more developer-friendly approach but has not yet been tested internally. Its status may change as we evaluate its suitability for our use cases.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["task scheduling"],
      "position": [195, 616]
    },
    {
      "id": "pydantic",
      "release": "2025-02-19",
      "title": "pydantic",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Pydantic is a Python library for data validation and settings management, built on type hints. It ensures runtime type enforcement and automatic data parsing, making it the preferred choice for API development (e.g., FastAPI). Compared to alternatives like marshmallow or Cerberus, Pydantic stands out for its performance and ease of use, especially in projects needing strict validation or typed settings (pydantic-settings).</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [231, 332]
    },
    {
      "id": "pydantic-settings",
      "release": "2025-02-19",
      "title": "pydantic-settings",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>pydantic-settings is built on Pydantic for managing typed and validated settings through environment variables and configuration files. It integrates well with Pydantic-based applications and focuses on strict typing, validation and testing. While it overlaps with Dynaconf, it’s better suited for simpler setups. For more complex configurations involving external services or multiple sources, Dynaconf may be a better fit.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [182, 262]
    },
    {
      "id": "pygad",
      "release": "2025-02-19",
      "title": "PyGAD",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>PyGAD is a Python library for building and optimizing solutions using genetic algorithms. It is easy to use, actively maintained, and well-suited for various optimization tasks, including neural network parameter tuning. With built-in functionality and good documentation, PyGAD is a practical choice for evolutionary algorithm-based solutions.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [461, 337]
    },
    {
      "id": "pylance",
      "release": "2025-02-19",
      "title": "pylance",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Pylance is the official language server for Python in Visual Studio Code, providing fast and accurate IntelliSense, type checking, and code navigation. It integrates tightly with mypy and Pyright, offering strong static analysis while maintaining good performance. As the recommended language server for VS Code, Pylance is the default choice for Python development in this environment.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [354, 343]
    },
    {
      "id": "pylint",
      "release": "2025-02-19",
      "title": "Pylint",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>Pylint is a static code analysis tool for Python, enforcing coding standards and detecting errors. While comprehensive, it can be overly strict and produce a high number of false positives, leading to frustration and reduced usability. With the adoption of Ruff for linting, which offers much faster performance and more practical rule sets, Pylint is no longer recommended for new projects. Even for existing projects, switching to Ruff is advised.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["code formatting"],
      "position": [541, 56]
    },
    {
      "id": "pyproj",
      "release": "2025-02-19",
      "title": "pyproj",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>pyproj is a library for cartographic projections and coordinate transformations. It is built on the PROJ library and is essential for working with geospatial data in different coordinate reference systems (CRS). While libraries like GeoPandas use pyproj internally, it remains useful for direct CRS transformations when fine-grained control is needed. It integrates well with other geospatial libraries such as Shapely and GeoPandas.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [543, 367]
    },
    {
      "id": "pysdx",
      "release": "2025-02-19",
      "title": "pysdx",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>pysdx is an internal VITO package built by Lorenz Hambsch for the analysis of spatial data with support for Postgis, with a ton of utility functions.\nAlthough it&#39;s used by a lot of projects today, the code is outdated, no longer guaranteed to work and a lot of the functionality is available in geopandas by now.\nLorenz is planning a pysdx refresh. Until then, if you need pysdx functionality, check with Lorenz first; there may be simpler ways to achieve what you need.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [573, 64]
    },
    {
      "id": "pytest",
      "release": "2025-02-19",
      "title": "pytest",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>pytest is the preferred testing framework for Python due to its simplicity and powerful features. It offers easy parameterization, flexible fixture management, and a rich command-line interface. pytest integrates well with CI/CD pipelines and supports plugins for features like code coverage reports. Compared to unittest, pytest is more concise and user-friendly, making it the better choice for most testing scenarios.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [482, 304]
    },
    {
      "id": "pytest-cov",
      "release": "2025-02-19",
      "title": "pytest-cov",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>pytest-cov is a plugin for pytest that provides test coverage reports using coverage.py. It is widely used, integrates seamlessly with pytest, and helps ensure code quality by tracking untested code paths. A great addition if you already have unittests with pytest.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [308, 367]
    },
    {
      "id": "python-dotenv",
      "release": "2025-02-19",
      "title": "python-dotenv",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>python-dotenv is a lightweight library for loading environment variables from .env files into Python applications. It’s an effective approach for managing configuration, especially in development and testing environments. By using .env files, you can avoid hardcoding passwords and credentials directly into your code—a common mistake.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["general"],
      "position": [348, 307]
    },
    {
      "id": "pytorch",
      "release": "2025-02-19",
      "title": "Pytorch",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>PyTorch is the preferred framework for research and custom model development. Its dynamic computation graph and Pythonic interface make it easier to use, debug, and iterate compared to TensorFlow. PyTorch has become the dominant framework in academia and is increasingly adopted in industry for exploratory work and custom neural network design.\nUse PyTorch when flexibility, ease of experimentation, and fast iteration are priorities. For large-scale production systems, TensorFlow may be a better fit due to its mature deployment tools.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [545, 319]
    },
    {
      "id": "pyyaml",
      "release": "2025-02-19",
      "title": "pyyaml",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>PyYAML is a package to parse YAML (YAML Ain’t Markup Language) files. Use YAML files to store large, complex, yet human-readable configuration files. For small and simple configuration files, consider TOML. For machine-generated or machine-interpretable configuration files, consider JSON.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [495, 347]
    },
    {
      "id": "rasterio",
      "release": "2025-02-19",
      "title": "rasterio",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Rasterio is a Python library for reading and writing geospatial raster data. Built on GDAL, it offers a more Pythonic and readable interface, making it easier to work with raster datasets. It integrates well with libraries like NumPy and Shapely, enabling efficient spatial data processing.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [429, 335]
    },
    {
      "id": "requests",
      "release": "2025-02-19",
      "title": "requests",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Requests is the standard library for making HTTP requests in Python. It simplifies working with APIs and web services, handling common tasks like authentication, sessions, and JSON parsing. With wide adoption, excellent documentation, and a clean API, it remains the preferred choice for HTTP communication in Python.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [457, 244]
    },
    {
      "id": "rioxarray",
      "release": "2025-02-19",
      "title": "rioxarray",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>rioxarray extends xarray with geospatial capabilities, making it easier to work with raster data in Python. Built on rasterio, it supports reading, writing, and manipulating geospatial data with coordinate reference system (CRS) management. It integrates seamlessly with xarray, allowing for more efficient analysis of multi-dimensional geospatial datasets. rioxarray is the preferred tool for combining geospatial and scientific data workflows.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [492, 277]
    },
    {
      "id": "rtree",
      "release": "2025-02-19",
      "title": "rtree",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>Rtree is a spatial indexing library that wraps the C-based libspatialindex. It is used for efficient spatial queries, such as finding the nearest neighbors or intersecting geometries. While essential for performance, you shouldn&#39;t use it directly, and instead use geopandas, which uses rtree under the hood.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [720, 194]
    },
    {
      "id": "ruff",
      "release": "2025-02-19",
      "title": "ruff",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Ruff is our code formatter and linter of choice. It is exceptionally fast, supports a wide range of linting rules, and integrates seamlessly with all major IDEs. Ruff is rapidly evolving, with type-checking features on the way, making it a robust alternative to traditional tools like Flake8. Its speed and versatility make it an essential tool for maintaining clean, consistent Python code.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["code formatting"],
      "position": [575, 360]
    },
    {
      "id": "s3fs",
      "release": "2025-02-19",
      "title": "s3fs",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>s3fs is a wrapper around boto3 that provides a more Pythonic, filesystem-like interface for interacting with S3, similar to pathlib. It simplifies common file operations but still depends on boto3 under the hood. While useful, it is being evaluated for broader adoption due to potential limitations in performance and feature completeness.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [303, 179]
    },
    {
      "id": "scikit-learn",
      "release": "2025-02-19",
      "title": "scikit-learn",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>scikit-learn is the reference library for classical machine learning in Python. It provides a comprehensive toolbox for supervised and unsupervised learning, with well-supported techniques such as linear regression, random forests, support vector machines, k-means clustering, and more. Its consistent API, excellent documentation, and integration with NumPy, SciPy, and pandas make it the go-to library for most machine learning tasks outside of deep learning.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [444, 261]
    },
    {
      "id": "scipy",
      "release": "2025-02-19",
      "title": "scipy",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>SciPy builds on NumPy to provide advanced scientific and numerical computing capabilities. It includes modules for optimization, signal processing, linear algebra, interpolation, and statistical functions. Many scientific and engineering applications rely on SciPy, making it a core library for numerical analysis in Python. Its integration with NumPy and widespread use in research and industry justify its adoption.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [460, 275]
    },
    {
      "id": "seaborn",
      "release": "2025-02-19",
      "title": "seaborn",
      "ring": "hold",
      "quadrant": "research-dev",
      "body": "<p>Seaborn is a Python library for creating static visualizations, built on top of Matplotlib. Through the &#39;grammar of graphic&#39; complex plots can be created with minimal code. While it is a solid option for static plots, we recommend using Plotly for most visualization tasks due to its interactivity and modern aesthetics. Seaborn should only be used when Plotly can&#39;t handle specific requirements for static visualizations.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["visualization"],
      "position": [754, 263]
    },
    {
      "id": "shapely",
      "release": "2025-02-19",
      "title": "shapely",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>Shapely is a library for geometric operations and spatial analysis in Python. While more low-level than GeoPandas, it provides the core geometry functions that GeoPandas builds on. In many cases, GeoPandas can handle spatial tasks without direct Shapely usage, in which case you&#39;re encourage to avoid using Shapely directly.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [479, 378]
    },
    {
      "id": "slurm",
      "release": "2025-02-19",
      "title": "Slurm",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>Slurm is a scalable and reliable workload manager designed for high-performance computing (HPC) environments. It is widely used in research for managing and scheduling jobs on large compute clusters. Slurm’s flexibility, extensive documentation, and support for diverse job types make it the preferred choice for research-focused workloads.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["deployment"],
      "position": [280, 449]
    },
    {
      "id": "spytools",
      "release": "2025-02-19",
      "title": "spytools",
      "ring": "trial",
      "quadrant": "research-dev",
      "body": "<p>SPyTools provides functionalities for reading and writing data to a SharePoint. It can also handle various types of spatial and non-spatial data formats such as GeoTIFF, GeoPackage, NetCDF, CSV, Excel, and more.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [637, 296]
    },
    {
      "id": "sqlalchemy",
      "release": "2025-02-19",
      "title": "sqlalchemy",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>SQLAlchemy is the standard ORM and database toolkit for Python, offering a flexible approach to working with relational databases. It supports both lightweight query execution and full model-based schema definitions. With strong documentation, broad adoption, and extensive use within VITO, it is the preferred choice for database interaction in Python.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [566, 320]
    },
    {
      "id": "sqlite",
      "release": "2025-02-19",
      "title": "SQLite",
      "ring": "adopt",
      "quadrant": "infra",
      "body": "<p>SQLite is becoming the DBMS of choice for simple backends that deal with e.g. only two tables. In such a setting, PostgreSQL is overkill. SQLite is exposed to the application by mounting it from a shared location of the cluster.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["database"],
      "position": [340, 494]
    },
    {
      "id": "streamlit",
      "release": "2025-02-19",
      "title": "streamlit",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>Streamlit is a fast and easy-to-use framework for building interactive web applications directly from Python scripts. It’s particularly useful in a research context for quickly creating data dashboards, experiment visualization tools, and interactive prototypes without needing frontend expertise. Streamlit supports live updates, integrates well with pandas, matplotlib, and Plotly, and is ideal for sharing results and insights in a more engaging format.</p>\n<p>We are currently trialing Streamlit for the Balmatt project, and it’s showing strong promise as a tool for building user-friendly interfaces to explore and visualize data interactively.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["visualization"],
      "position": [173, 358]
    },
    {
      "id": "tensorflow-keras",
      "release": "2025-02-19",
      "title": "tensorflow/keras",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>TensorFlow is a comprehensive machine learning framework designed for both research and production, while Keras provides a high-level API for building models on top of TensorFlow. Keras simplifies model design with a more user-friendly interface, making it ideal for quick prototyping and small to medium-sized projects. For large-scale applications or performance-critical tasks, pure TensorFlow offers greater flexibility and control.</p>\n<p>Use TensorFlow/Keras when you need scalability, integration with TensorFlow&#39;s ecosystem (e.g., TensorFlow Lite for mobile or TensorFlow Serving for deployment), or when working on deep learning in production. For more research-oriented projects, consider PyTorch.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [514, 270]
    },
    {
      "id": "toml",
      "release": "2025-02-19",
      "title": "toml",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>toml is a package to parse TOML files: a human-readable configuration file format, commonly used for Python project settings (e.g., pyproject.toml). Also for basic configuration tasks, it&#39;s a powerful alternative to JSON or YAML. For more complex human-readable configuration, we suggest using YAML.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [475, 260]
    },
    {
      "id": "tqdm",
      "release": "2025-02-19",
      "title": "tqdm",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>tqdm is a lightweight library for adding progress bars to Python loops and long-running computations. It integrates easily with standard Python, pandas, and even asynchronous tasks. Its simplicity and versatility make it an invaluable tool for tracking the progress of computational jobs or optimizations with minimal effort.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["logging"],
      "position": [526, 308]
    },
    {
      "id": "trimesh",
      "release": "2025-02-19",
      "title": "trimesh",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>trimesh is a library for working with 3D triangular meshes. It provides tools for loading, analyzing, and manipulating mesh data, making it useful in 3D modeling (mesh simplification, converting between different 3D file formats). It integrates well with NumPy and supports multiple export formats.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [434, 393]
    },
    {
      "id": "trio",
      "release": "2025-02-19",
      "title": "trio",
      "ring": "trial",
      "quadrant": "app-dev",
      "body": "<p>Trio is a Python library for structured concurrency, offering a simpler and more reliable approach to async programming compared to asyncio. It integrates well with httpx but has a smaller ecosystem, which may limit adoption. While promising, it is still being evaluated for broader use.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["general"],
      "position": [174, 287]
    },
    {
      "id": "typeguard",
      "release": "2025-02-19",
      "title": "typeguard",
      "ring": "assess",
      "quadrant": "app-dev",
      "body": "<p>Typeguard is a runtime type-checking library for Python that verifies type annotations at runtime. It complements static type checkers like mypy by ensuring type correctness during execution. While useful for catching type errors that static analysis might miss, it can introduce some runtime overhead. Use Typeguard for debugging and testing in type-annotated projects, especially in cases where stricter type enforcement is needed. For static-only checking, rely on mypy.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [86, 317]
    },
    {
      "id": "typer",
      "release": "2025-02-19",
      "title": "typer",
      "ring": "adopt",
      "quadrant": "app-dev",
      "body": "<p>Typer is a modern library for building command-line interfaces (CLI) in Python. Built on top of Click and inspired by FastAPI, it uses type hints to provide automatic validation, help messages, and autocompletion. It simplifies CLI development while maintaining clarity and scalability. Compared to argparse, Typer offers a more intuitive developer experience with less boilerplate code and better support for complex CLIs. It works especially well with Pydantic. It’s the preferred choice when building modern CLIs, especially if type safety, easy maintenance, and rich documentation are priorities.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["cli"],
      "position": [258, 306]
    },
    {
      "id": "unittest",
      "release": "2025-02-19",
      "title": "unittest",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>unittest is the built-in testing framework in Python, providing a consistent and reliable way to write tests. However, compared to pytest, it is more verbose and less flexible, with limited features for parameterization and fixture management. Given pytest&#39;s superior developer experience, powerful command-line tools, and extensive plugin support, we recommend using pytest for new projects. Existing tests in unittest can be maintained, but new tests should use pytest.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [299, 57]
    },
    {
      "id": "uv",
      "release": "2025-02-19",
      "title": "uv",
      "ring": "trial",
      "quadrant": "env-pkg-mgmt",
      "body": "<p>uv is an all-in-one tool for Python version management, package management, and lockfile handling. It offers a streamlined approach to managing environments and dependencies. It is (currently) limited by its lack of compatibility with Conda repositories, which can be tricky for some research projects. Very promising, but we&#39;re still evaluating this.</p>\n",
      "featured": true,
      "flag": "default",
      "position": [590, 569]
    },
    {
      "id": "validators",
      "release": "2025-02-19",
      "title": "validators",
      "ring": "hold",
      "quadrant": "app-dev",
      "body": "<p>validators is a lightweight Python library for validating the syntax of common objects like URLs, email addresses, IP addresses, and IBANs. It provides a simple and consistent API for performing basic validation checks. While it’s useful for quick input validation, for more robust and customizable validation requirements, consider using specialized libraries such as Cerberus or pydantic.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["typing", "validation and testing"],
      "position": [270, 38]
    },
    {
      "id": "xarray",
      "release": "2025-02-19",
      "title": "xarray",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>xarray simplifies working with labeled multi-dimensional arrays, offering an intuitive API similar to pandas but for multi-dimensional data. It is particularly useful in domains like geospatial analysis, where multi-band raster images or time-series data are common. xarray integrates well with NumPy, Dask, and Rasterio, making it a powerful tool for handling large datasets with named dimensions and coordinates.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data wrangling"],
      "position": [525, 357]
    },
    {
      "id": "xgboost",
      "release": "2025-02-19",
      "title": "xgboost",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>xgboost is a powerful library for gradient boosting, widely used in machine learning for structured/tabular data. Known for its speed and accuracy, it supports regression, classification, and ranking tasks. It integrates well with scikit-learn and offers features like early stopping and tree pruning. For deep learning tasks, consider TensorFlow or PyTorch instead.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["machine learning"],
      "position": [550, 294]
    },
    {
      "id": "xmltodict",
      "release": "2025-02-19",
      "title": "xmltodict",
      "ring": "adopt",
      "quadrant": "research-dev",
      "body": "<p>xmltodict is a Python library for converting XML data into easy-to-use Python dictionaries. It simplifies working with XML by avoiding the complexity of traditional XML parsers. This makes it ideal for quickly reading and processing XML data in projects where JSON-like access patterns are preferred. It’s particularly useful for configurations, APIs, and data exchange formats that rely on XML.</p>\n",
      "featured": true,
      "flag": "default",
      "tags": ["data i/o"],
      "position": [448, 319]
    }
  ]
}
